# Knot

###### project description
    Knot is a literate programming tool. You may wish to take a look at [other
    tools][]; [nuweb][] and [noweb][] are particularly significant. There is
    also [lit][], which also uses Markdown for its syntax.

    Knot is self-hosting -- even this `README.md` is generated by the program.
    [Check it out!](knot.md)

    [other tools]: https://en.wikipedia.org/wiki/Literate_programming#Tools
    [nuweb]: http://nuweb.sourceforge.net/
    [noweb]: http://www.cs.tufts.edu/~nr/noweb/
    [lit]: https://github.com/cdosborn/lit


    ## Rationale

    I think literate programming is awesome, but I don't like that it's
    LaTeX-based because

    1. I would like to customize the HTML output more.
    1. It would facilitate sharing of my documents if the literate program were
       written in a markup supported by GitHub's READMEs.

    After reading [Joe Armstrong's literate program][] I decided that I could
    write my own -- a strong recommendation for literate programming!

    [Joe Armstrong's literate program]: https://www.sics.se/~joe/ericsson/literate/literate.html


## The Program

This is the layout of the module.

###### file:src/knot.erl
```erlang
%% This file was generated by knot.md using the literate program contained
%% therein.

-module(knot).
-compile(export_all).
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.
###### includes

###### functions
###### debugging

-ifdef(TEST).
###### tests
-endif.
```


### Reading in Code Sections

Unlike some other literate programming tools, we don't weave documentation
together. So the first thing we need to do is divide up an input string into
`code sections`.

We're going to need a few utility functions for collecting the code sections.
These `collect` functions will all return a two-tuple of the collected text and
the rest of the input, i.e. `{"foo", "bar baz buzz"}`.

#### collect_to_eol

Splits the input up until the next line break. This will be used in operations
on single lines.

###### functions
```erlang
collect_to_eol(Input) ->
    collect_to_eol(Input, "").

collect_to_eol("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_eol([$\n | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_eol([Char | Rest], Acc) ->
    collect_to_eol(Rest, [Char | Acc]).
```

###### tests
```erlang
collect_to_eol_test() ->
    {"", ""} = collect_to_eol(""),
    {"foo", "bar\nbaz"} = collect_to_eol("foo\nbar\nbaz"),
    {"foo", ""} = collect_to_eol("foo\n").
```


#### collect_to_fence

Splits the input up until the next line that starts with three backticks. This
will be used to identify to select code sections and ignore documentation
sections.

###### functions
```erlang
collect_to_fence(Input) ->
    collect_to_fence(Input, "").

collect_to_fence("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_fence([$\n, $`, $`, $` | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_fence([Char | Rest], Acc) ->
    collect_to_fence(Rest, [Char | Acc]).
```

###### tests
```erlang
collect_to_fence_test() ->
    {"foobar", ""} = collect_to_fence("foobar"),
    {"my\ncode\nhere", "\nmore input"} = collect_to_fence("my\ncode\nhere\n```\nmore input").
```


#### collect_to_unindent

Splits the input up until the next line that starts with non-white space. This
will find the end of indented code blocks.

###### functions
```erlang
collect_to_unindent(Input) ->
    collect_to_unindent(Input, "").

collect_to_unindent("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_unindent([$\n | Rest], Acc) ->
    case re:run(Rest, "^\\S") of
        {match, _} ->
            % Must put the line break back on to detect the next code section.
            {lists:reverse(Acc), [$\n | Rest]};
        nomatch ->
            collect_to_unindent(Rest, [$\n | Acc])
    end;

collect_to_unindent([Char | Rest], Acc) ->
    collect_to_unindent(Rest, [Char | Acc]).
```

###### tests
```erlang
collect_to_unindent_test() ->
    {"foobar", ""} = collect_to_unindent("foobar"),
    {"    my\n    code\n    here\n", "\nmy documentation"} = collect_to_unindent("    my\n    code\n    here\n\nmy documentation").
```

It's important that `collect_to_unindent` doesn't consume the matched line
break. In cases where one code section immediately follows another, we need the
line break to detect the start of the next section. See `all_code` for the
pattern match that requires that.


#### collect_code

Now we can collect all the code sections in a literate document. This function
will establish the following markup conventions.

> If you use GitHub Flavored Markdown's [fenced code blocks][], then the fence
> must start on the line immediately after the code section H6.
>
> Otherwise, the code must be indented and will end right before the first line
> that doesn't start with white space.

[fenced code blocks]: https://help.github.com/articles/github-flavored-markdown/#fenced-code-blocks

###### functions
```erlang
collect_code([$`, $`, $` | Rest]) ->
    % There might be a syntax highlighting hint that we can ignore.
    {_, Rest1} = collect_to_eol(Rest),
    collect_to_fence(Rest1);

collect_code(Input) ->
    collect_to_unindent(Input).
```

###### tests
```erlang
fenced_collect_code_test() ->
    Input = "```erlang\n"
            "\n"
            "-module(foobar).\n"
            "-compile(export_all).\n"
            "\n"
            "foo() ->\n"
            "    ok.\n"
            "```\n"
            "\n"
            "documentation\n",
    Expected_section = "\n"
                     "-module(foobar).\n"
                     "-compile(export_all).\n"
                     "\n"
                     "foo() ->\n"
                     "    ok.",
    Expected_rest = "\n\ndocumentation\n",
    {Expected_section, Expected_rest} = collect_code(Input).


indented_collect_code_test() ->
    Input = "\n"
            "    -module(foobar).\n"
            "    -compile(export_all).\n"
            "\n"
            "    foo() ->\n"
            "        ok.\n"
            "\n"
            "documentation\n",
    Expected_section = "\n"
                     "    -module(foobar).\n"
                     "    -compile(export_all).\n"
                     "\n"
                     "    foo() ->\n"
                     "        ok.\n",
    Expected_rest = "\ndocumentation\n",
    {Expected_section, Expected_rest} = collect_code(Input).
```


#### all_code

This will return all code section from the input. This establishes the markup
conventions that:

> An H6 in the leading `#` style marks a code section. For example, to output a
> file: `###### file:src/knot.erl`.


###### functions
```erlang
all_code(Input) ->
    all_code(Input, []).

all_code("", Acc) ->
    lists:reverse(Acc);

all_code([$\n, $#, $#, $#, $#, $#, $#, $  | Rest], Acc) ->
    {Name, Rest1} = collect_to_eol(Rest),
    {Code, Rest2} = collect_code(Rest1),
    all_code(Rest2, [{Name, Code} | Acc]);

all_code([_ | Rest], Acc) ->
    all_code(Rest, Acc).
```

###### tests
```erlang
all_code_test() ->
    Input = "A sample document.\n"
            "\n"
            "\###### indented code section\n"
            "\n"
            "    Code 1, line 1.\n"
            "    Code 1, line 2.\n"
            "\n"
            "More documentation.\n"
            "\n"
            "\###### fenced code section\n"
            "```erlang\n"
            "Code 2, line 1.\n"
            "Code 2, line 2.\n"
            "```\n"
            "\n"
            "End of sample document.\n",

    Expected = [{"indented code section", "\n    Code 1, line 1.\n    Code 1, line 2.\n"},
                {"fenced code section", "Code 2, line 1.\nCode 2, line 2."}],

    Expected = all_code(Input).

all_code_no_intermediate_documentation_test() ->
    Input = "A sample document.\n"
            "\n"
            "\###### indented code section\n"
            "\n"
            "    Code 1, line 1.\n"
            "    Code 1, line 2.\n"
            "\n"
            "\###### another indented code section\n"
            "    Code 2, line 1.\n"
            "    Code 2, line 2.\n"
            "\n"
            "The end.\n",

    Expected = [{"indented code section", "\n    Code 1, line 1.\n    Code 1, line 2.\n"},
                {"another indented code section", "    Code 2, line 1.\n    Code 2, line 2.\n"}],

    Expected = all_code(Input).
```


### Processing

Now that we've got the code sections we can process them. We need to:

1. Unindent the code.
1. Concatenate sections.
1. Expand sections.
1. Unescape escaped sequences.


#### Unindent Code

To remove indentation we have to first find indentation. The indentation we
need to strip is defined as the leading white space on the first line without
white space. So, given a source file like this

    Some documentation.

    ###### my code

        foo() ->
            ok.

...the indentation is four spaces because the first line with non white space
(`foo() ->`) starts with four spaces.

###### functions
```erlang
find_indentation("") ->
    "";

find_indentation(Code) ->
    {Line, Rest} = collect_to_eol(Code),
    case re:run(Line, "^(?<white>\\s*)\\S", [{capture, [white], list}]) of
        {match, [White]} ->
            White;
        nomatch ->
            find_indentation(Rest)
    end.
```

###### tests
```erlang
find_indentation_test() ->
    "" = find_indentation(""),
    "" = find_indentation("    \n\t  \n    \nsomething"),
    "\t" = find_indentation("\n\n\tsomething\n\n"),
    "    " = find_indentation("\n    something").
```

Now we can use `find_indentation` to strip the indentation from all lines of
code.

###### functions
```erlang
unindent(Code) ->
    case find_indentation(Code) of
        "" ->
            Code;
        Indentation ->
            Pattern = [$^ | Indentation],
            unindent(Code, Pattern, [])
    end.

unindent("", _Pattern, Lines) ->
    string:join(lists:reverse(Lines), "\n");

unindent(Code, Pattern, Lines) ->
    {Line, Rest} = collect_to_eol(Code),
    Unindented_line = re:replace(Line, Pattern, "", [{return, list}]),
    unindent(Rest, Pattern, [Unindented_line | Lines]).
```

###### tests
```erlang
unindent_four_spaces_test() ->
    Input = "\n\n    foo() ->\n        ok.\n\n",
    Expected = "\n\nfoo() ->\n    ok.\n",
    Expected = unindent(Input).

unindent_nothing_test() ->
    Input = "\nfoo() ->\n    ok.\n",
    Input = unindent(Input).

unindent_tabs_test() ->
    Input = "\n\tfoo() ->\n\t\tok.\n",
    Expected = "\nfoo() ->\n\tok.",
    Expected = unindent(Input).
```

**TODO**: The `collect_to_eol` is causing the output from `unindent` to strip
the trailing line. Try and figure out if this is an issue.

And apply it to all sections.

###### functions
```erlang
unindent_sections(Sections) ->
    lists:map(fun ({Name, Code}) ->
                  {Name, unindent(Code)}
              end,
              Sections).
```

###### tests
```erlang
unindent_sections_test() ->
    Input = [{"foo", "\tfoo() ->\n\t\tok."},
             {"bar", "    foo() ->\n        ok."}],

    Expected = [{"foo", "foo() ->\n\tok."},
                {"bar", "foo() ->\n    ok."}],

    Expected = unindent_sections(Input).
```


#### Concatenate Sections

When sections of code have the same name they need to be concatenated.

###### functions
```erlang
concat_sections(Sections) ->
    Join_sections = fun (Key, Acc) ->
        Values = proplists:get_all_values(Key, Sections),
        Joined = string:join(Values, "\n"),
        [{Key, Joined} | Acc]
    end,

    lists:foldr(Join_sections, [], proplists:get_keys(Sections)).
```

###### tests
```erlang
concat_sections_test() ->
    Input = [{"foo", "FOO"},
             {"bar", "BAR"},
             {"foo", "FOO"}],

    Expected = [{"foo", "FOO\nFOO"},
                {"bar", "BAR"}],

    Expected = concat_sections(Input).
```


#### Expand Sections

In other literate programming tools, the expanded section will follow the
indentation of the line. I want to do something a little different. I want a
code section like this

    This is a list of things.
    <ul>
        <li>###### list of elements ######</li>
    </ul>

and another section like this

    one
    two
    three

to expand to

    This is a list of things.
    <ul>
        <li>one</li>
        <li>two</li>
        <li>three</li>
    </ul>

I decided I wanted to do this when I was using [noweb][] to assemble a Makefile
and wanted to assemble inline bash scripts and I had to have ` \` as a suffix
to every line. It would have been elegant to have the usage above.

I did a version of this where the sections were identified with regex. The
pattern was ugly and long. Then I wanted to use backslash to escape the section
delimeter. It was too hard; it would only piss me off when I came back to it
later.

So, I'll start with a `collect` function that splits a line at a section
delimeter.

This establishes a markup requirement.

> Any sequence of 6 `#` in a code section that are not to be expanded must be
> escaped with a leading backslash: `\######`.

###### functions
```erlang
collect_to_section_delimeter(Line) ->
    collect_to_section_delimeter(Line, "").

collect_to_section_delimeter("", Acc) ->
    {lists:reverse(Acc), ""};

% Ignores escaped delimeters.
collect_to_section_delimeter([$\\, $#, $#, $#, $#, $#, $# | Rest], Acc) ->
    collect_to_section_delimeter(Rest, [$#, $#, $#, $#, $#, $#, $\\ | Acc]);

collect_to_section_delimeter([$#, $#, $#, $#, $#, $# | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_section_delimeter([Char | Rest], Acc) ->
    collect_to_section_delimeter(Rest, [Char | Acc]).
```

###### tests
```erlang
collect_to_section_delimeter_test() ->
    {"foobar", ""} = collect_to_section_delimeter("foobar"),
    {"    ", " my section"} = collect_to_section_delimeter("    \###### my section"),
    {"- ", " my section \###### -"} = collect_to_section_delimeter("- \###### my section \###### -"),
    {"my section ", " -"} = collect_to_section_delimeter("my section \###### -"),
    {"\\\###### not a section", ""} = collect_to_section_delimeter("\\\###### not a section").
```

And now `section` will return `nil` or a three-tuple of `{Name, Prefix, Suffix}`
and establishes a markup convention that

> Sections with a trailing delimeter will be expanded with the line's prefix
> and suffix.

###### functions
```erlang
split_section(Line) ->
    case collect_to_section_delimeter(Line) of
        {_, ""} ->
            % No section in this line.
            nil;

        {Prefix, Rest} ->
            % Rest contains the section name and, potentially, another
            % delimeter before the suffix.
            {Padded_name, Suffix} = collect_to_section_delimeter(Rest),
            {string:strip(Padded_name), Prefix, Suffix}
    end.
```

###### tests
```erlang
section_test() ->
    nil = split_section("foobar"),
    {"my section", "    ", ""} = split_section("    \###### my section"),
    {"my section", "    <li>", "</li>"} = split_section("    <li>\###### my section \######</li>").
```


With `expand_sections`, a source file like this

    ###### my code
        ###### things
        - ###### things ###### -

    ###### things
        one
        two

will expand to

    one
    two
    - one -
    - two -

###### functions
```erlang
expand_sections(Code, Sections) ->
    expand_sections(Code, Sections, []).

expand_sections("", _Sections, Acc) ->
    string:join(lists:reverse(Acc), "\n");

expand_sections(Code, Sections, Acc) ->
    {Line, Rest} = collect_to_eol(Code),
    case split_section(Line) of
        nil ->
            expand_sections(Rest, Sections, [Line | Acc]);

        {Name, Prefix, Suffix} ->
            case proplists:get_value(Name, Sections) of
                undefined ->
                    io:format("Warning: code section named ~p not found.~n", [Name]),
                    expand_sections(Rest, Sections, [Prefix ++ Suffix| Acc]);

                Code_to_insert ->
                    New_lines = re:split(Code_to_insert, "\n", [{return, list}]),
                    Wrapped = lists:map(fun (X) -> Prefix ++ X ++ Suffix end, New_lines),
                    expand_sections(Rest, Sections, [string:join(Wrapped, "\n") | Acc])
            end
    end.
```

###### tests
```erlang
expand_sections_test() ->
    Input_code = "\n"
                 "start\n"
                 "\###### things\n"
                 "- \###### things \###### -\n"
                 "    \###### unused\n"
                 "end\n",
    Input_sections= [{"things", "one\ntwo"}],
    Expected = "\nstart\none\ntwo\n- one -\n- two -\n    \nend",
    Expected = expand_sections(Input_code, Input_sections).
```


And now we have to do that for every section.

###### functions
```erlang
expand_all_sections(Sections) ->
    expand_all_sections(Sections, Sections, []).

expand_all_sections([], _Sections, Acc) ->
    lists:reverse(Acc);

expand_all_sections([{Name, Code} | Rest], Sections, Acc) ->
    expand_all_sections(Rest, Sections, [{Name, expand_sections(Code, Sections)} | Acc]).
```


###### tests
```erlang
expand_all_sections_test() ->
    Input = [{"first one", "First.\n\###### list of things"},
             {"second one", "This...\n-\###### list of things \######-\nis the second."},
             {"All the things!", "\###### first one \######\n* \###### second one \###### *\nDone."},
             {"list of things", "one\ntwo"}],

    Expected = [{"first one", "First.\none\ntwo"},
                {"second one", "This...\n-one-\n-two-\nis the second."},
                {"All the things!", "First.\none\ntwo\n* This... *\n* -one- *\n* -two- *\n* is the second. *\nDone."},
                {"list of things", "one\ntwo"}],

    Expected = expand_all_sections(expand_all_sections(Input)).
```


#### Unescape Escaped Sequences

If you're in a code section and need to use `######`, then you must escape it.
As a final step in the processing of literate files, I will unescape the
escaped H6s.

The backslash is used in regex patterns, so we need to double up.

###### functions
```erlang
unescape(Code) ->
    re:replace(Code, "\\\\\######", "\######", [global, {return, list}]).
```

###### tests
```erlang
unescape_test() ->
    "foo\n    \###### not a section\nbar" = unescape("foo\n    \\\###### not a section\nbar"),
    "- \\\###### really not a section \\\###### -" = unescape("- \\\\\###### really not a section \\\\\###### -"),
    "\###### h6 of another Markdown document \######" = unescape("\\\###### h6 of another Markdown document \\\######").
```

And do it for all sections.

###### functions
```erlang
unescape_sections(Sections) ->
    unescape_sections(Sections, []).

unescape_sections([], Acc) ->
    lists:reverse(Acc);

unescape_sections([{Name, Code} | Rest], Acc) ->
    unescape_sections(Rest, [{Name, unescape(Code)} | Acc]).
```

###### tests
```erlang
unescape_sections_test() ->
    Input = [{"foo", "\\\######"},
             {"bar", "bar"},
             {"baz", "\\\###### h6 of another Markdown document \\\######"}],

    Expected = [{"foo", "\######"},
                {"bar", "bar"},
                {"baz", "\###### h6 of another Markdown document \######"}],

    Expected = unescape_sections(Input).
```

### Debugging

I'll want to provide something on the command line to help debug each stage in
the file processing.

The good thing about the functions I've already written is that they only take
one argument for input, so it's pretty easy to pass in a string of text
representing a partial document. However, I'll want to pass in a source file
and just see what code sections are detected.

First I'll need to read files in and output sections of code in various stages
of processing.

###### debugging
```erlang
read_file(File_name) ->
    case file:read_file(File_name) of
        {ok, Binary} ->
            binary_to_list(Binary);
        {error, Reason} ->
            io:format("Failed to read file (~s): ~s~n", [File_name, Reason]),
            error({read_file, File_name, Reason})
    end.

print_sections(Sections) ->
    lists:foreach(fun ({Name, Code}) ->
                      io:format("~s~n-----~n~s~n-----~n~n",
                                [Name, Code])
                  end,
                  Sections).
```

And now we can print the various stages.

###### debugging
```erlang
print_code(File_name) ->
    print_sections(
        all_code(
            read_file(File_name))).

print_unindented_code(File_name) ->
    print_sections(
        unindent_sections(
            all_code(
                read_file(File_name)))).

print_concatenated_code(File_name) ->
    print_sections(
        concat_sections(
            unindent_sections(
                all_code(
                    read_file(File_name))))).

print_expanded_code(File_name) ->
    print_sections(
        expand_all_sections(
            concat_sections(
                unindent_sections(
                    all_code(
                        read_file(File_name)))))).

print_unescaped_code(File_name) ->
    print_sections(
        unescape_sections(
            expand_all_sections(
                concat_sections(
                    unindent_sections(
                        all_code(
                            read_file(File_name))))))).
```


### Writing Files

The input is fully processed now. This program wouldn't be useful without we
write some files. This is pretty simple because we only need to find the
sections with names prefixed with `file:`.

###### functions
```erlang
file_sections(Sections) ->
    file_sections(Sections, []).

file_sections([], Acc) ->
    lists:reverse(Acc);

file_sections([{[$f, $i, $l, $e, $: | _] = Name, Code} | Rest], Acc) ->
    file_sections(Rest, [{Name, Code} | Acc]);

file_sections([_ | Rest], Acc) ->
    file_sections(Rest, Acc).
```

###### tests
```erlang
file_sections_test() ->
    Input = [{"file:a", "a"},
             {"not a file", "not a file"},
             {"file:b", "b"}],
    Expected = [{"file:a", "a"},
                {"file:b", "b"}],
    Expected = file_sections(Input).
```

Might want to debug it, too.

###### debugging
```erlang
print_file_sections(File_name) ->
    print_sections(
        file_sections(
            unescape_sections(
                expand_all_sections(
                    concat_sections(
                        unindent_sections(
                            all_code(
                                read_file(File_name)))))))).
```

Given file sections, write them. The reason we're using a `Base_directory` for
these functions is that the output files will be relative to the source file.
This gives us another markup requirement:

> File names given in `file:` sections are relative to the source file.

If the output directory doesn't exist, an error is printed but not raised. I
don't want the watch command to shut down if an invalid output file is added to
the document.

###### functions
```erlang
file_name(Base_directory, File_name) ->
    filename:nativename(filename:absname_join(Base_directory, File_name)).

write_file(Base_directory, File_name, Contents) ->
    Fn = file_name(Base_directory, File_name),
    case file:write_file(Fn, Contents) of
        ok -> Fn;
        {error, Reason} ->
            io:format("Error: Failed to write file (~s): ~s. "
                      "(Knot doesn't create directories, so you may need to "
                      "create one.)~n", [Fn, Reason])
    end.
```

###### tests
```erlang
file_name_test() ->
    "test_files/foobar.txt" = file_name("test_files", "foobar.txt"),
    "/path/to/repository/src/knot.erl" = file_name("/path/to/repository", "src/knot.erl").

write_file_test() ->
    "test_files/test.txt" = write_file("test_files", "test.txt", "write_file_test\n"),
    {ok, <<"write_file_test\n">>} = file:read_file(file_name("test_files", "test.txt")),
    file:delete(file_name("test_files", "test.txt")).
```


### Putting it All Together

`process_file` will do everything! For nested section expansion, I arbitrarily
decided to do it four times. I'm not concerned about performance and it seems
reasonable.

###### functions
```erlang
process_file(File_name) ->
    Base_directory = filename:dirname(File_name),
    Concatenated_code = concat_sections(
                            unindent_sections(
                                all_code(
                                    read_file(File_name)))),
    Expanded_code = expand_all_sections(
                        expand_all_sections(
                            expand_all_sections(
                                expand_all_sections(Concatenated_code)))),
    Files = file_sections(
                unescape_sections(Expanded_code)),

    write_file_sections(Base_directory, Files, []).

write_file_sections(_Base_directory, [], Files_written) ->
    lists:reverse(Files_written);

write_file_sections(Base_directory, [{[$f, $i, $l, $e, $: | File_name], Contents} | Rest], Files_written) ->
    New_file = write_file(Base_directory, File_name, Contents),
    write_file_sections(Base_directory, Rest, [New_file | Files_written]).
```

###### tests
```erlang
process_file_test() ->
    ["test_files/process_file_test.js"] = process_file("test_files/process_file_test.md"),
    Expected = read_file("test_files/process_file_test.js.expected_output"),
    Actual = read_file("test_files/process_file_test.js") ++ "\n",
    % ?debugVal(Expected),
    % ?debugVal(Actual),
    Expected = Actual,
    file:delete("test_files/process_file_test.js").
```

**TODO**: The process_file test has to manually append a new line because my
editor always appends a new line at the end of the file. I had to add it to
pass the test -- I think this is because of the way I use `collect_to_eol`
without returning the matched line break. But is this an issue? I'm not sure.

Handle multiple files.

###### functions
```erlang
process_files(Files) ->
    process_files(Files, []).

process_files([], Files_written) ->
    % Files_written is a list of lists of strings. Strings are lists, too,
    % so lists:flatten can't be used becuause it turns into a single
    % string.
    lists:concat(lists:reverse(Files_written));

process_files([File | Files], Files_written) ->
    process_files(Files, [process_file(File) | Files_written]).
```

**TODO**: The output of process_files in this test has `1_a` and `1_b`
reversed. The parser only uses lists of tuples, and the source file has `a`
before `b`. (Also, the other files come out ordered properly.) I don't *think*
this is a problem; it only matters that the output is correct. There might be a
bug, though. For now I will use `lists:member` to validate the output.

###### tests
```erlang
process_files_test() ->
    Output_files = ["test_files/process_files_1_a.txt",
                    "test_files/process_files_1_b.txt",
                    "test_files/process_files_2_a.txt",
                    "test_files/process_files_2_b.txt",
                    "test_files/process_files_3_a.txt",
                    "test_files/process_files_3_b.txt"],
    Actual = process_files(["test_files/process_files_1.md",
                            "test_files/process_files_2.md",
                            "test_files/process_files_3.md"]),

    true = lists:all(fun (X) ->
                        lists:member(X, Output_files)
                     end,
                     Actual),

    6 = length(Actual),

    lists:map(fun file:delete/1, Actual).
```


### Packaging it in an `escript`.

I'd like to have as little dependencies as possible. With an escript, the
installation instructions should be as simple as 'install Erlang, put script in
path'.

###### file:knot
```erlang
#!/usr/bin/env escript
%% -*- erlang -*-

%% This file was generated by knot.md using the literate program contained
%% therein.

###### includes

usage() ->
    io:format("###### escript usage ######~n"),
    ok.

main([]) ->
    usage();

main(["print_code", File]) -> print_code(File);
main(["print_unindented_code", File]) -> print_unindented_code(File);
main(["print_concatenated_code", File]) -> print_concatenated_code(File);
main(["print_expanded_code", File]) -> print_expanded_code(File);
main(["print_unescaped_code", File]) -> print_unescaped_code(File);
main(["print_file_sections", File]) -> print_file_sections(File);

###### other escript entry points

main(Args) ->
    case lists:any(fun (X) -> lists:member(X, ["help", "-h", "-help", "--help"]) end, Args) of
        true ->
            usage();
        false ->
            process_files(Args)
    end.

###### debugging
###### functions
```

Since I provided that special prefix and suffix to maco expansion, my script
usage is formatted really well! It get automatically wrapped in the `io:format`
code.

###### escript usage
    knot - a literate programming tool.

    Usage: knot [file]...
           ###### other usage ######

    Syntax: Knot files are literare programs written in Markdown. For
            information about the syntax, please check the GitHub page:
            https://github.com/mqsoh/knot.

    ###### other usage descriptions ######

    There are some debugging functions that are tied to the way the parser
    handles the document. The following supplementary usage is available:

        knot print_code [file]
        knot print_unindented_code [file]
        knot print_concatenated_code [file]
        knot print_expanded_code [file]
        knot print_unescaped_code [file]
        knot print_file_sections[file]

    For more information about them, it's probably best to read the literate
    program.

### Project README

###### file:README.md
    # Knot

    ###### project description

    ## Usage

    Knot files are written in Markdown.

    They will use the `\######`-style H6 to denote potential code sections. If
    the name of the section starts with `file:` then a file with that name will
    be written (relative to the source document).

    Two types of code sections are supported: indented code sections (typical
    of Markdown) and GitHub Flavored Markdown's fenced code blocks.

    Code expansion also uses `\######`. As with other literate programming
    tools, indentation is maintained. However, there is a feature that I
    believe is unique to knot that will expand code with the line's prefix and
    suffix.

    If you need to escape the `\######` (as I have, since Knot is
    self-hosting), prefix it with a backslash, e.g. `\\######`.

    ### Example

    A file like this:

        This is a simple literate program that outputs `my_file.txt`.

        \###### file:my_file.txt
            I am in my file.

            Some things:

            - \###### my things \###### -

            \###### footer

        My things are just three numbers.

        \###### my things
            one
            two
            three

        And the footer just shows the abbreviated style.

        \###### footer
            It tasted like a foot.

    ...will output `my_file.txt` like this:

        I am in my file.

        Some things:

        - one -
        - two -
        - three -

        It tasted like a foot.

    ## Installation

    Install Erlang.

        sudo apt-get install erlang

    Put the [knot](knot) escript somewhere in your path.


### File Watching

A lot of tools that compile to source code, like compass and all that Node.js
stuff, provide a watch command. This will automatically recompile the source
documents. They usually watch a directory and this is usually done with
`inotify` bindings. There is [a project that provides Erlang bindings][], but I
don't want any dependencies. Erlang doesn't have a package manager like `pip`
or `npm` so any other dependencies will necessarily complicate the installation
of this program.

[a project that provides Erlang bindings]: https://github.com/massemanet/inotify

I happen to have tried out a bit of code from Mochiweb that will automatically
reload Erlang modules when it detects changes to the `.beam` files. It does
this with simple polling and I will do that, too.

Knot will already accept a list of files as input, so I will use that and poll
for changes to the modified time. This has one down side. I can't watch a
directory so if a new file is created then the watch command will have to be
restarted. Let's warn the user of that:

###### watch warning
    The watch command polls the files you provide for modifications. It does
    not watch directories. If you add a new file you will have to re-start this
    command.


I'll start by getting one file's modified time.

###### includes
```erlang
-include_lib("kernel/include/file.hrl").
```
###### functions
```erlang
file_modified_time(File_name) ->
    {ok, Info} = file:read_file_info(File_name),
    Info#file_info.mtime.
```

###### tests
```erlang
file_modified_time_test() ->
    {Day, _} = calendar:local_time(),
    {Day, _} = file_modified_time("knot.erl").
```


Now get the modified time of a list of files.

###### functions
```erlang
modified_times(Files) ->
    Fun = fun (X, A) ->
        [{X, file_modified_time(X)} | A]
    end,
    lists:foldl(Fun, [], Files).
```

###### tests
```erlang
modified_times_test() ->
    Files = ["knot.beam", "knot.erl"],
    Modified_times = modified_times(Files),

    {Today, _} = calendar:local_time(),
    {Today, _} = proplists:get_value("knot.beam", Modified_times),
    {Today, _} = proplists:get_value("knot.erl", Modified_times).
```


Now we can poll for changes. This function will take a function to perform
work. It will be passed a list of changed files.

###### functions
```erlang
watch(Files, Fun) ->
    watch(Files, Fun, []).

watch(Files, Fun, State) ->
    Modified_times = modified_times(existing_files(Files)),
    Changed_files = changed_files(Modified_times, State),

    case length(Changed_files) > 0 of
        true ->
            apply(Fun, [Changed_files]);
        _ -> noop
    end,

    % wait
    timer:sleep(timer:seconds(1)),

    % loop
    watch(Files, Fun, Modified_times).
```

The `watch` implementation included a `changed_files` function that I need to
write now. It needs to check for any keys that have different values.

###### functions
```erlang
changed_files(A, B) ->
    Fun = fun (X, Acc) ->
        case proplists:get_value(X, A) =:= proplists:get_value(X, B) of
            false ->
                [X | Acc];
            _ -> Acc
        end
    end,
    lists:foldl(Fun, [], proplists:get_keys(A)).
```

I'm not going to run tests on these functions. `watch` is a blocking function
and if I want to run it as a process, I need to (I think) use `gen_server` and
the `timer` module to send messages. It's got some boiler plate, so I don't
feel like doing that.

Now we need to wrap it in command line execution. I actually had to go up to
the escript definition in `file:knot` to add the ability to insert command line
arguments. I'm not sure Don Knuth ever needed to do stuff like that in his
example literate programs. On the other hand, surely he edited his own work.
Maybe the only issue I have is the naming of it. Not sure, anyway, how about
this fragment to provide it on the command line.

###### other escript entry points
```erlang
main(["watch" | Files]) ->
    watch(Files,
          fun (Changed_files) ->
            Print = fun (X) -> io:format("~s~n", [X]) end,

            io:format("~n----- Processing -----~n"),
            lists:foreach(Print, Changed_files),

            Output_files = process_files(Changed_files),

            io:format("----- Output -----~n"),
            lists:foreach(Print, Output_files)
          end);
```

###### other usage
    knot watch [file]...

###### other usage descriptions
    The 'knot watch' usage will take a list of files. When a change is detected
    on any of the files, knot will automatically recompile them.

The watch function was giving me trouble with vim. Vim deletes a file and
recreates it from the swapped version. I don't recall the details of that, but
basically the watch function doesn't work because the Erlang interpreter exits
when attempt file operations on the file while it's deleted.

I added an `existing_files` function call to the `watch` implementation above.
I think that it would be easiest if we first filtered all of the non-existant
files because there are multiple that will be performed later -- the check on
modified time and then the read when processing files.

###### functions
```erlang
existing_files(Files) ->
    lists:filter(fun filelib:is_file/1, Files).
```

###### tests
```erlang
existing_files_test() ->
    Input = ["../knot.md", "i_will_never_exist.txt"],
    Expected = ["../knot.md"],
    Expected = existing_files(Input).
```
