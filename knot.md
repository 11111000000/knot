# Knot

```{.markdown name="project description"}
Knot is a literate programming tool. You may wish to take a look at [other
tools][]; [nuweb][] and [noweb][] are particularly significant. There is
also [lit][], which also uses Markdown for its syntax.

Knot is self-hosting -- even this `README.md` is generated by the program.
[Check it out!](knot.md)

[other tools]: https://en.wikipedia.org/wiki/Literate_programming#Tools
[nuweb]: http://nuweb.sourceforge.net/
[noweb]: http://www.cs.tufts.edu/~nr/noweb/
[lit]: https://github.com/cdosborn/lit


## Rationale

I think literate programming is awesome, but I don't like that it's
LaTeX-based because

1. I would like to customize the HTML output more.
1. It would facilitate sharing of my documents if the literate program were
   written in a markup supported by GitHub's READMEs.

After reading [Joe Armstrong's literate program][] I decided that I could
write my own -- a strong recommendation for literate programming!

[Joe Armstrong's literate program]: https://www.sics.se/~joe/ericsson/literate/literate.html
```


## The Program

This is the layout of the module.

```{.erlang name="file:src/knot.erl"}
%% This file was generated by knot.md using the literate program contained
%% therein.

-module(knot).
-compile(export_all).
-ifdef(TEST).
-include_lib("eunit/include/eunit.hrl").
-endif.
<<includes>>

<<functions>>
<<debugging>>

-ifdef(TEST).
<<tests>>
-endif.
```


### Reading in Code Sections

Unlike some other literate programming tools, we don't weave documentation
together. So the only thing we need to do is divide up an input string into
`code sections`.

We're going to need a few utility functions for collecting the code sections.
These `collect_*` functions will all return a two-tuple of the collected text and
the rest of the input, i.e. `{"foo", "bar"}`.

#### collect_to_eol

Splits the input up until the next line break. This will be used in operations
on single lines.

TODO: I think all I need to do to support the three line ending variants is to
use pattern matching in this order: `\r\n`, `\n`, and `\r`. However, I think
there are other areas where I put a `\n` back in the stream manually or pattern
match against `\n`. I will look into this. It's possible that I need to
parameterize this. Perhaps the `collect_*` functions can return a
three-tuple...

```{.erlang name="functions"}
collect_to_eol(Input) ->
    collect_to_eol(Input, "").

collect_to_eol("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_eol([$\n | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_eol([Char | Rest], Acc) ->
    collect_to_eol(Rest, [Char | Acc]).
```

```{.erlang name="tests"}
collect_to_eol_test() ->
    {"", ""} = collect_to_eol(""),
    {"foo", "bar\nbaz"} = collect_to_eol("foo\nbar\nbaz"),
    {"foo", ""} = collect_to_eol("foo\n").
```


#### collect_to_fence

Splits the input up until the next line that starts with three backticks. This
will be used to identify to select code sections and ignore documentation
sections.

This establishes a markup rule that:

> Code blocks are ended with three backticks at the start of a line. (A typical
> fenced code block.)

```{.erlang name="functions"}
collect_to_fence(Input) ->
    collect_to_fence(Input, "").

collect_to_fence("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_fence([$\n, $`, $`, $` | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_fence([Char | Rest], Acc) ->
    collect_to_fence(Rest, [Char | Acc]).
```

```{.erlang name="tests"}
collect_to_fence_test() ->
    {"foobar", ""} = collect_to_fence("foobar"),
    {"my\ncode\nhere", "\nmore input"} = collect_to_fence("my\ncode\nhere\n```\nmore input").
```


#### all_code

This will return all code section from the input. This establishes the markup
conventions that:

> The name of the code block must match the pattern: `name="my code section name"`
>
> The document must have at least one line before the first code block.

```{.erlang name="functions"}
all_code(Input) ->
    all_code(Input, []).

all_code("", Acc) ->
    lists:reverse(Acc);

all_code([$\n, $`, $`, $` | Rest], Acc) ->
    {Attributes, Rest1} = collect_to_eol(Rest),
    {match, [Name]} = re:run(Attributes,
                             "name=\"(?<name>[^\"]+)\"",
                             [{capture, [name], list}]),
    {Code, Rest2} = collect_to_fence(Rest1),
    all_code(Rest2, [{Name, Code} | Acc]);

all_code([_ | Rest], Acc) ->
    all_code(Rest, Acc).
```

```{.erlang name="tests"}
all_code_test() ->
    Input = "A sample document.\n"
            "\n"
            "``` {.erlang name=\"section 1\"}\n"
            "Code 1, line 1.\n"
            "Code 1, line 2.\n"
            "```\n"
            "\n"
            "More documentation.\n"
            "\n"
            "```{name=\"section 2\"}\n"
            "Code 2, line 1.\n"
            "Code 2, line 2.\n"
            "```\n"
            "\n"
            "End of sample document.\n",

    Expected = [{"section 1", "Code 1, line 1.\nCode 1, line 2."},
                {"section 2", "Code 2, line 1.\nCode 2, line 2."}],

    Expected = all_code(Input).

all_code_no_intermediate_documentation_test() ->
    Input = "A sample document.\n"
            "\n"
            "``` {.fake name=\"section 1\"}\n"
            "\n"
            "Code 1, line 1.\n"
            "Code 1, line 2.\n"
            "```\n"
            "``` {.fake name=\"section 2\"}\n"
            "Code 2, line 1.\n"
            "Code 2, line 2.\n"
            "```\n"
            "The end.\n",

    Expected = [{"section 1", "\nCode 1, line 1.\nCode 1, line 2."},
                {"section 2", "Code 2, line 1.\nCode 2, line 2."}],

    Expected = all_code(Input).
```


### Processing

Now that we've got the code sections we can process them. We need to:

1. Concatenate sections.
1. Expand sections.
1. Unescape escaped sequences.


#### Concatenate Sections

When sections of code have the same name they need to be concatenated.

```{.erlang name="functions"}
concat_sections(Sections) ->
    Join_sections = fun (Key, Acc) ->
        Values = proplists:get_all_values(Key, Sections),
        Joined = string:join(Values, "\n"),
        [{Key, Joined} | Acc]
    end,

    lists:foldr(Join_sections, [], proplists:get_keys(Sections)).
```

```{.erlang name="tests"}
concat_sections_test() ->
    Input = [{"foo", "FOO"},
             {"bar", "BAR"},
             {"foo", "FOO"}],

    Expected = [{"foo", "FOO\nFOO"},
                {"bar", "BAR"}],

    Expected = concat_sections(Input).
```


#### Expand Sections

In other literate programming tools, the expanded section will follow the
indentation of the line. I want to do something a little different. I want a
code section like this

    This is a list of things.
    <ul>
        <li><<list of elements>>li>
    </ul>

and another section like this

    one
    two
    three

to expand to

    This is a list of things.
    <ul>
        <li>one</li>
        <li>two</li>
        <li>three</li>
    </ul>

I decided I wanted to do this when I was using [noweb][] to assemble a Makefile
and wanted to assemble inline bash scripts. I had to have ` \` as a suffix
to every line. It would have been elegant to have the usage above.

I did a version of this where the sections were identified with regex. The
pattern was ugly and long. Then I wanted to use backslash to escape the section
delimeter. It was too hard; it would only piss me off when I came back to it
later.

So, I'll start with a `collect` function that splits a line at a section
delimeter.

This establishes a markup requirement.

> Any sequence of `<<` in a code section that are not to be expanded must be
> escaped with a leading backslash: `\<<`.

```{.erlang name="functions"}
collect_to_replacement_open(Line) ->
    collect_to_replacement_open(Line, "").

collect_to_replacement_open("", Acc) ->
    {lists:reverse(Acc), ""};

% Ignores escaped delimeters.
collect_to_replacement_open([$\\, $<, $< | Rest], Acc) ->
    collect_to_replacement_open(Rest, [$<, $<, $\\ | Acc]);

collect_to_replacement_open([$<, $< | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_replacement_open([Char | Rest], Acc) ->
    collect_to_replacement_open(Rest, [Char | Acc]).
```

Since knot is self-hosting, the escaping is a little complicated. The first
level is to prevent knot from inserting its own sections. The second level is
actually to test the escaping. Since it's inside an Erlang string, the second
level needs two back-slashes. (It may help to compare the Erlang source code
for knot in [src/knot.erl](src/knot.erl).)

```{.erlang name="tests"}
collect_to_replacement_open_test() ->
    {"foobar", ""} = collect_to_replacement_open("foobar"),
    {"    ", "my replacement>>"} = collect_to_replacement_open("    \<<my replacement>>"),
    {"- ", "my replacement>> -"} = collect_to_replacement_open("- \<<my replacement>> -"),
    {"\\\<<not a replacement>>", ""} = collect_to_replacement_open("\\\<<not a replacement>>").
```

And now `split_section` will return `nil` or a three-tuple of `{Name, Prefix, Suffix}`
and establishes a markup convention that

> Sections with a trailing delimeter will be expanded with the line's prefix
> and suffix.

```{.erlang name="functions"}
split_section(Line) ->
    case collect_to_replacement_open(Line) of
        {_, ""} ->
            % No section in this line.
            nil;

        {Prefix, Rest} ->
            % Rest contains the section name and the closing delimiter.
            {Padded_name, Suffix} = collect_to_replacement_close(Rest),
            {string:strip(Padded_name), Prefix, Suffix}
    end.
```

```{.erlang name="tests"}
split_section_test() ->
    nil = split_section("foobar"),
    {"my section", "    ", ""} = split_section("    \<<my section>>"),
    {"my section", "    <li>", "</li>"} = split_section("    <li>\<<my section>></li>").
```

In an older version of knot, the opening and closing delimeters of replacements
was the same. Since we're following the `<<name>>` style now, we need to
implement `collect_to_replacement_close` used in the `split_section` function.

TODO: I really, really hate the names of these functions. They are too verbose.
It just occurred to me that I can probably create a parameterized function for
collecting to arbitrary delimeters. This would replace all the `collect_*`
functions.

```{.erlang name="functions"}
collect_to_replacement_close(Input) ->
    collect_to_replacement_close(Input, []).

collect_to_replacement_close("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_replacement_close([$>, $> | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_replacement_close([Char | Rest], Acc) ->
    collect_to_replacement_close(Rest, [Char | Acc]).
```

```{.erlang name="tests"}
collect_to_replacement_close_test() ->
    {"foobar", ""} = collect_to_replacement_close("foobar"),
    {"my replacement", "..."} = collect_to_replacement_close("my replacement>>...").
```

With `expand_sections`, a source file like this

    ```{name="my code"}
    <<things>>
    - <<things>> -
    ```

    ```{name="things"}
    one
    two
    ```

will expand to

    one
    two
    - one -
    - two -

```{.erlang name="functions"}
expand_sections(Code, Sections) ->
    expand_sections(Code, Sections, []).

expand_sections("", _Sections, Acc) ->
    string:join(lists:reverse(Acc), "\n");

expand_sections(Code, Sections, Acc) ->
    {Line, Rest} = collect_to_eol(Code),
    case split_section(Line) of
        nil ->
            expand_sections(Rest, Sections, [Line | Acc]);

        {Name, Prefix, Suffix} ->
            case proplists:get_value(Name, Sections) of
                undefined ->
                    io:format("Warning: code section named ~p not found.~n", [Name]),
                    expand_sections(Rest, Sections, [Prefix ++ Suffix| Acc]);

                Code_to_insert ->
                    New_lines = re:split(Code_to_insert, "\n", [{return, list}]),
                    Wrapped = lists:map(fun (X) -> Prefix ++ X ++ Suffix end, New_lines),
                    expand_sections(Rest, Sections, [string:join(Wrapped, "\n") | Acc])
            end
    end.
```

```{.erlang name="tests"}
expand_sections_test() ->
    Input_code = "\n"
                 "start\n"
                 "\<< things >>\n"
                 "- \<<things>> -\n"
                 "    \<<unused>>\n"
                 "end\n",
    Input_sections= [{"things", "one\ntwo"}],
    Expected = "\nstart\none\ntwo\n- one -\n- two -\n    \nend",
    Expected = expand_sections(Input_code, Input_sections).
```


And now we have to do that for every section.

```{.erlang name="functions"}
expand_all_sections(Sections) ->
    expand_all_sections(Sections, Sections, []).

expand_all_sections([], _Sections, Acc) ->
    lists:reverse(Acc);

expand_all_sections([{Name, Code} | Rest], Sections, Acc) ->
    expand_all_sections(Rest, Sections, [{Name, expand_sections(Code, Sections)} | Acc]).
```


```{.erlang name="tests"}
expand_all_sections_test() ->
    Input = [{"first one", "First.\n\<<list of things>>"},
             {"second one", "This...\n-\<<list of things>>-\nis the second."},
             {"All the things!", "\<<first one>>\n* \<<second one>> *\nDone."},
             {"list of things", "one\ntwo"}],

    Expected = [{"first one", "First.\none\ntwo"},
                {"second one", "This...\n-one-\n-two-\nis the second."},
                {"All the things!", "First.\none\ntwo\n* This... *\n* -one- *\n* -two- *\n* is the second. *\nDone."},
                {"list of things", "one\ntwo"}],

    Expected = expand_all_sections(expand_all_sections(Input)).
```


#### Unescape Escaped Sequences

If you're in a code section and need to use `<<` then you must escape it.
As a final step in the processing of literate files, I will unescape the
escaped `<<`s.

The backslash is used in regex patterns, so we need to double up.

```{.erlang name="functions"}
unescape(Code) ->
    re:replace(Code, "\\\\\<<", "\<<", [global, {return, list}]).
```

```{.erlang name="tests"}
unescape_test() ->
    "foo\n    \<<not a section>>\nbar" = unescape("foo\n    \\\<<not a section>>\nbar"),
    "- \\\<< really not a section>> -" = unescape("- \\\\\<< really not a section>> -").
```

And do it for all sections.

```{.erlang name="functions"}
unescape_sections(Sections) ->
    unescape_sections(Sections, []).

unescape_sections([], Acc) ->
    lists:reverse(Acc);

unescape_sections([{Name, Code} | Rest], Acc) ->
    unescape_sections(Rest, [{Name, unescape(Code)} | Acc]).
```

```{.erlang name="tests"}
unescape_sections_test() ->
    Input = [{"foo", "\\\<<"},
             {"bar", "bar"}],

    Expected = [{"foo", "\<<"},
                {"bar", "bar"}],

    Expected = unescape_sections(Input).
```

### Debugging

I'll want to provide something on the command line to help debug each stage in
the file processing.

The good thing about the functions I've already written is that they only take
one argument for input, so it's pretty easy to pass in a string of text
representing a partial document. However, I'll want to pass in a source file
and just see what code sections are detected.

First I'll need to read files in and output sections of code in various stages
of processing.

```{.erlang name="debugging"}
read_file(File_name) ->
    case file:read_file(File_name) of
        {ok, Binary} ->
            binary_to_list(Binary);
        {error, Reason} ->
            io:format("Failed to read file (~s): ~s~n", [File_name, Reason]),
            error({read_file, File_name, Reason})
    end.

print_sections(Sections) ->
    lists:foreach(fun ({Name, Code}) ->
                      io:format("~s~n-----~n~s~n-----~n~n",
                                [Name, Code])
                  end,
                  Sections).
```

And now we can print the various stages.

```{.erlang name="debugging"}
print_code(File_name) ->
    print_sections(
        all_code(
            read_file(File_name))).

print_unindented_code(File_name) ->
    print_sections(
        all_code(
            read_file(File_name))).

print_concatenated_code(File_name) ->
    print_sections(
        concat_sections(
            all_code(
                read_file(File_name)))).

print_expanded_code(File_name) ->
    print_sections(
        expand_all_sections(
            concat_sections(
                all_code(
                    read_file(File_name))))).

print_unescaped_code(File_name) ->
    print_sections(
        unescape_sections(
            expand_all_sections(
                concat_sections(
                    all_code(
                        read_file(File_name)))))).
```


### Writing Files

The input is fully processed now. This program wouldn't be useful without we
write some files. This is pretty simple because we only need to find the
sections with names prefixed with `file:`.

```{.erlang name="functions"}
file_sections(Sections) ->
    file_sections(Sections, []).

file_sections([], Acc) ->
    lists:reverse(Acc);

file_sections([{[$f, $i, $l, $e, $: | _] = Name, Code} | Rest], Acc) ->
    file_sections(Rest, [{Name, Code} | Acc]);

file_sections([_ | Rest], Acc) ->
    file_sections(Rest, Acc).
```

```{.erlang name="tests"}
file_sections_test() ->
    Input = [{"file:a", "a"},
             {"not a file", "not a file"},
             {"file:b", "b"}],
    Expected = [{"file:a", "a"},
                {"file:b", "b"}],
    Expected = file_sections(Input).
```

Might want to debug it, too.

```{.erlang name="debugging"}
print_file_sections(File_name) ->
    print_sections(
        file_sections(
            unescape_sections(
                expand_all_sections(
                    concat_sections(
                        all_code(
                            read_file(File_name))))))).
```

Given file sections, write them. The reason we're using a `Base_directory` for
these functions is that the output files will be relative to the source file.
This gives us another markup requirement:

> File names given in `file:` sections are relative to the source file.

If the output directory doesn't exist, an error is printed but not raised. I
don't want the watch command to shut down if an invalid output file is added to
the document.

```{.erlang name="functions"}
file_name(Base_directory, File_name) ->
    filename:nativename(filename:absname_join(Base_directory, File_name)).

write_file(Base_directory, File_name, Contents) ->
    Fn = file_name(Base_directory, File_name),
    case file:write_file(Fn, Contents) of
        ok -> Fn;
        {error, Reason} ->
            io:format("Error: Failed to write file (~s): ~s. "
                      "(Knot doesn't create directories, so you may need to "
                      "create one.)~n", [Fn, Reason])
    end.
```

```{.erlang name="tests"}
file_name_test() ->
    "test_files/foobar.txt" = file_name("test_files", "foobar.txt"),
    "/path/to/repository/src/knot.erl" = file_name("/path/to/repository", "src/knot.erl").

write_file_test() ->
    "test_files/test.txt" = write_file("test_files", "test.txt", "write_file_test\n"),
    {ok, \<<"write_file_test\n">>} = file:read_file(file_name("test_files", "test.txt")),
    file:delete(file_name("test_files", "test.txt")).
```


### Putting it All Together

`process_file` will do everything! For nested section expansion, I arbitrarily
decided to do it four times. I'm not concerned about performance and it seems
reasonable.

```{.erlang name="functions"}
process_file(File_name) ->
    Base_directory = filename:dirname(File_name),
    Concatenated_code = concat_sections(
                            all_code(
                                read_file(File_name))),
    Expanded_code = expand_all_sections(
                        expand_all_sections(
                            expand_all_sections(
                                expand_all_sections(Concatenated_code)))),
    Files = file_sections(
                unescape_sections(Expanded_code)),

    write_file_sections(Base_directory, Files, []).

write_file_sections(_Base_directory, [], Files_written) ->
    lists:reverse(Files_written);

write_file_sections(Base_directory, [{[$f, $i, $l, $e, $: | File_name], Contents} | Rest], Files_written) ->
    New_file = write_file(Base_directory, File_name, Contents),
    write_file_sections(Base_directory, Rest, [New_file | Files_written]).
```

```{.erlang name="tests"}
process_file_test() ->
    ["test_files/process_file_test.js"] = process_file("test_files/process_file_test.md"),
    Expected = read_file("test_files/process_file_test.js.expected_output"),
    Actual = read_file("test_files/process_file_test.js") ++ "\n",
    %?debugVal(Expected),
    %?debugVal(Actual),
    Expected = Actual,
    file:delete("test_files/process_file_test.js").
```

**TODO**: The process_file test has to manually append a new line because my
editor always appends a new line at the end of the file. I had to add it to
pass the test -- I think this is because of the way I use `collect_to_eol`
without returning the matched line break. But is this an issue? I'm not sure.

Handle multiple files.

```{.erlang name="functions"}
process_files(Files) ->
    process_files(Files, []).

process_files([], Files_written) ->
    % Files_written is a list of lists of strings. Strings are lists, too,
    % so lists:flatten can't be used becuause it turns into a single
    % string.
    lists:concat(lists:reverse(Files_written));

process_files([File | Files], Files_written) ->
    process_files(Files, [process_file(File) | Files_written]).
```

**TODO**: The output of process_files in this test has `1_a` and `1_b`
reversed. The parser only uses lists of tuples, and the source file has `a`
before `b`. (Also, the other files come out ordered properly.) I don't *think*
this is a problem; it only matters that the output is correct. There might be a
bug, though. For now I will use `lists:member` to validate the output.

```{.erlang name="tests"}
process_files_test() ->
    Output_files = ["test_files/process_files_1_a.txt",
                    "test_files/process_files_1_b.txt",
                    "test_files/process_files_2_a.txt",
                    "test_files/process_files_2_b.txt",
                    "test_files/process_files_3_a.txt",
                    "test_files/process_files_3_b.txt"],
    Actual = process_files(["test_files/process_files_1.md",
                            "test_files/process_files_2.md",
                            "test_files/process_files_3.md"]),

    true = lists:all(fun (X) ->
                        lists:member(X, Output_files)
                     end,
                     Actual),

    6 = length(Actual),

    lists:map(fun file:delete/1, Actual).
```


### Packaging it in an `escript`.

I'd like to have as little dependencies as possible. With an escript, the
installation instructions should be as simple as 'install Erlang, put script in
path'.

```{.erlang name="file:knot"}
#!/usr/bin/env escript
%% -*- erlang -*-

%% This file was generated by knot.md using the literate program contained
%% therein.

<<includes>>

usage() ->
    io:format("<<escript usage>>\n"),
    ok.

main([]) ->
    usage();

main(["print_code", File]) -> print_code(File);
main(["print_unindented_code", File]) -> print_unindented_code(File);
main(["print_concatenated_code", File]) -> print_concatenated_code(File);
main(["print_expanded_code", File]) -> print_expanded_code(File);
main(["print_unescaped_code", File]) -> print_unescaped_code(File);
main(["print_file_sections", File]) -> print_file_sections(File);

<<other escript entry points>>

main(Args) ->
    case lists:any(fun (X) -> lists:member(X, ["help", "-h", "-help", "--help"]) end, Args) of
        true ->
            usage();
        false ->
            process_files(Args)
    end.

<<debugging>>
<<functions>>
```

Since I provided that special prefix and suffix to maco expansion, my script
usage is formatted really well! It get automatically wrapped in the `io:format`
code.

```{name="escript usage"}
knot - a literate programming tool.

Usage: knot [file]...
       <<other usage>>

Syntax: Knot files are literare programs written in Markdown. For information
        about the syntax, please check the GitHub page:
        https://github.com/mqsoh/knot.

<<other usage descriptions>>

There are some debugging functions that are tied to the way the parser handles
the document. The following supplementary usage is available:

    knot print_code [file]
    knot print_unindented_code [file]
    knot print_concatenated_code [file]
    knot print_expanded_code [file]
    knot print_unescaped_code [file]
    knot print_file_sections[file]

For more information about them, it's probably best to read the literate
program.
```

### Project README

```{.markdown name="file:README.md"}
# Knot

<<project description>>

## Usage

Knot files are written in Markdown.

They will use Pandoc style fenced code, i.e. ``` ```{name="foobar"} ```. If the
name of the section starts with `file:` then a file with that name will be
written (relative to the source document).

Two types of code sections are supported: indented code sections (typical of
Markdown) and GitHub Flavored Markdown's fenced code blocks.

Code expansion also uses `\<<section name>>`. As with other literate
programming tools, indentation is maintained. However, there is a feature that
I believe is unique to knot that will expand code with the line's prefix and
suffix.

If you need to escape the `\<<` (as I have, since Knot is
self-hosting), prefix it with a backslash, e.g. `\\<<`.

### Example

A file like this:

    This is a simple literate program that outputs `my_file.txt`.

    ```{name="file:my_file.txt"}
    I am in my file.

    Some things:

    - \<<my things>> -

    \<<footer>>
    ```

    My things are just three numbers.

    ```{name="my things"}
    one
    two
    three
    ```

    And the footer is just other content.

    ```{name="footer"}
    It tasted like a foot.
    ```

...will output `my_file.txt` like this:

    I am in my file.

    Some things:

    - one -
    - two -
    - three -

    It tasted like a foot.

## Installation

Install Erlang.

    sudo apt-get install erlang

Put the [knot](knot) escript somewhere in your path.
```


### File Watching

A lot of tools that compile to source code, like compass and all that Node.js
stuff, provide a watch command. This will automatically recompile the source
documents. They usually watch a directory and this is usually done with
`inotify` bindings. There is [a project that provides Erlang bindings][], but I
don't want any dependencies. Erlang doesn't have a package manager like `pip`
or `npm` so any other dependencies will necessarily complicate the installation
of this program.

[a project that provides Erlang bindings]: https://github.com/massemanet/inotify

I happen to have tried out a bit of code from Mochiweb that will automatically
reload Erlang modules when it detects changes to the `.beam` files. It does
this with simple polling and I will do that, too.

Knot will already accept a list of files as input, so I will use that and poll
for changes to the modified time. This has one down side. I can't watch a
directory so if a new file is created then the watch command will have to be
restarted. Let's warn the user of that:

```{name="watch warning"}
The watch command polls the files you provide for modifications. It does not
watch directories. If you add a new file you will have to re-start this
command.
```


I'll start by getting one file's modified time.

```{.erlang name="includes"}
-include_lib("kernel/include/file.hrl").
```

```{.erlang name="functions"}
file_modified_time(File_name) ->
    {ok, Info} = file:read_file_info(File_name),
    Info#file_info.mtime.
```


```{.erlang name="tests"}
file_modified_time_test() ->
    {Day, _} = calendar:local_time(),
    {Day, _} = file_modified_time("knot.erl").
```


Now get the modified time of a list of files.


```{.erlang name="functions"}
modified_times(Files) ->
    Fun = fun (X, A) ->
        [{X, file_modified_time(X)} | A]
    end,
    lists:foldl(Fun, [], Files).
```

```{.erlang name="tests"}
modified_times_test() ->
    Files = ["knot.beam", "knot.erl"],
    Modified_times = modified_times(Files),

    {Today, _} = calendar:local_time(),
    {Today, _} = proplists:get_value("knot.beam", Modified_times),
    {Today, _} = proplists:get_value("knot.erl", Modified_times).
```


Now we can poll for changes. This function will take a function to perform
work. It will be passed a list of changed files.

```{.erlang name="functions"}
watch(Files, Fun) ->
    watch(Files, Fun, []).

watch(Files, Fun, State) ->
    Modified_times = modified_times(existing_files(Files)),
    Changed_files = changed_files(Modified_times, State),

    case length(Changed_files) > 0 of
        true ->
            apply(Fun, [Changed_files]);
        _ -> noop
    end,

    % wait
    timer:sleep(timer:seconds(1)),

    % loop
    watch(Files, Fun, Modified_times).
```

The `watch` implementation included a `changed_files` function that I need to
write now. It needs to check for any keys that have different values.

```{.erlang name="functions"}
changed_files(A, B) ->
    Fun = fun (X, Acc) ->
        case proplists:get_value(X, A) =:= proplists:get_value(X, B) of
            false ->
                [X | Acc];
            _ -> Acc
        end
    end,
    lists:foldl(Fun, [], proplists:get_keys(A)).
```

I'm not going to run tests on these functions. `watch` is a blocking function
and if I want to run it as a process, I need to (I think) use `gen_server` and
the `timer` module to send messages. It's got some boiler plate, so I don't
feel like doing that.

Now we need to wrap it in command line execution. I actually had to go up to
the escript definition in `file:knot` to add the ability to insert command line
arguments. I'm not sure Don Knuth ever needed to do stuff like that in his
example literate programs. On the other hand, surely he edited his own work.
Maybe the only issue I have is the naming of it. Not sure, anyway, how about
this fragment to provide it on the command line.

```{.erlang name="other escript entry points"}
main(["watch" | Files]) ->
    watch(Files,
          fun (Changed_files) ->
            Print = fun (X) -> io:format("~s~n", [X]) end,

            io:format("~n----- Processing -----~n"),
            lists:foreach(Print, Changed_files),

            Output_files = process_files(Changed_files),

            io:format("----- Output -----~n"),
            lists:foreach(Print, Output_files)
          end);
```

```{name="other usage"}
knot watch [file]...
```

```{name="other usage descriptions"}
The 'knot watch' usage will take a list of files. When a change is detected on
any of the files, knot will automatically recompile them.
```

The watch function was giving me trouble with vim. Vim deletes a file and
recreates it from the swapped version. I don't recall the details of that, but
basically the watch function doesn't work because the Erlang interpreter exits
when attempt file operations on the file while it's deleted.

I added an `existing_files` function call to the `watch` implementation above.
I think that it would be easiest if we first filtered all of the non-existant
files because there are multiple that will be performed later -- the check on
modified time and then the read when processing files.

```{.erlang name="functions"}
existing_files(Files) ->
    lists:filter(fun filelib:is_file/1, Files).
```

```{.erlang name="tests"}
existing_files_test() ->
    Input = ["../knot.md", "i_will_never_exist.txt"],
    Expected = ["../knot.md"],
    Expected = existing_files(Input).
```
