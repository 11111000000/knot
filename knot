#!/usr/bin/env escript
%% -*- erlang -*-

%% This file was generated by knot.md using the literate program contained
%% therein.

-include_lib("kernel/include/file.hrl").

usage() ->
    io:format("knot - a literate programming tool.~n"),
    io:format("~n"),
    io:format("Usage: knot [file]...~n"),
    io:format("       knot watch [file]...~n"),
    io:format("~n"),
    io:format("Syntax: Knot files are literare programs written in Markdown. For~n"),
    io:format("        information about the syntax, please check the GitHub page:~n"),
    io:format("        https://github.com/mqsoh/knot.~n"),
    io:format("~n"),
    io:format("The 'knot watch' usage will take a list of files. When a change is detected~n"),
    io:format("on any of the files, knot will automatically recompile them.~n"),
    io:format("~n"),
    io:format("There are some debugging functions that are tied to the way the parser~n"),
    io:format("handles the document. The following supplementary usage is available:~n"),
    io:format("~n"),
    io:format("    knot print_code [file]~n"),
    io:format("    knot print_unindented_code [file]~n"),
    io:format("    knot print_concatenated_code [file]~n"),
    io:format("    knot print_expanded_code [file]~n"),
    io:format("    knot print_unescaped_code [file]~n"),
    io:format("    knot print_file_blocks [file]~n"),
    io:format("~n"),
    io:format("For more information about them, it's probably best to read the literate~n"),
    io:format("program.~n"),
    ok.

main([]) ->
    usage();

main(["print_code", File]) -> print_code(File);
main(["print_unindented_code", File]) -> print_unindented_code(File);
main(["print_concatenated_code", File]) -> print_concatenated_code(File);
main(["print_expanded_code", File]) -> print_expanded_code(File);
main(["print_unescaped_code", File]) -> print_unescaped_code(File);
main(["print_file_blocks", File]) -> print_file_blocks(File);

main(["watch" | Files]) ->
    watch(Files,
          fun (Changed_files) ->
            Print = fun (X) -> io:format("~s~n", [X]) end,

            io:format("~n----- Processing -----~n"),
            lists:foreach(Print, Changed_files),

            Output_files = process_files(Changed_files),

            io:format("----- Output -----~n"),
            lists:foreach(Print, Output_files)
          end);

main(Args) ->
    case lists:any(fun (X) -> lists:member(X, ["help", "-h", "-help", "--help"]) end, Args) of
        true ->
            usage();
        false ->
            process_files(Args)
    end.

read_file(File_name) ->
    {ok, Binary} = file:read_file(File_name),
    binary_to_list(Binary).

print_blocks(Blocks) ->
    lists:foreach(fun ({Name, Code}) ->
                      io:format("~s~n-----~n~s~n-----~n~n",
                                [Name, Code])
                  end,
                  Blocks).
print_code(File_name) ->
    print_blocks(
        all_code(
            read_file(File_name))).

print_unindented_code(File_name) ->
    print_blocks(
        unindent_blocks(
            all_code(
                read_file(File_name)))).

print_concatenated_code(File_name) ->
    print_blocks(
        concat_blocks(
            unindent_blocks(
                all_code(
                    read_file(File_name))))).

print_expanded_code(File_name) ->
    print_blocks(
        expand_all_macros(
            concat_blocks(
                unindent_blocks(
                    all_code(
                        read_file(File_name)))))).

print_unescaped_code(File_name) ->
    print_blocks(
        unescape_blocks(
            expand_all_macros(
                concat_blocks(
                    unindent_blocks(
                        all_code(
                            read_file(File_name))))))).
print_file_blocks(File_name) ->
    print_blocks(
        file_blocks(
            unescape_blocks(
                expand_all_macros(
                    concat_blocks(
                        unindent_blocks(
                            all_code(
                                read_file(File_name)))))))).
collect_to_eol(Input) ->
    collect_to_eol(Input, "").

collect_to_eol("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_eol([$\n | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_eol([Char | Rest], Acc) ->
    collect_to_eol(Rest, [Char | Acc]).
collect_to_fence(Input) ->
    collect_to_fence(Input, "").

collect_to_fence("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_fence([$\n, $`, $`, $` | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_fence([Char | Rest], Acc) ->
    collect_to_fence(Rest, [Char | Acc]).
collect_to_unindent(Input) ->
    collect_to_unindent(Input, "").

collect_to_unindent("", Acc) ->
    {lists:reverse(Acc), ""};

collect_to_unindent([$\n | Rest], Acc) ->
    case re:run(Rest, "^\\S") of
        {match, _} ->
            % Must put the line break back on to detect the next code block.
            {lists:reverse(Acc), [$\n | Rest]};
        nomatch ->
            collect_to_unindent(Rest, [$\n | Acc])
    end;

collect_to_unindent([Char | Rest], Acc) ->
    collect_to_unindent(Rest, [Char | Acc]).
collect_code([$`, $`, $` | Rest]) ->
    % There might be a syntax highlighting hint that we can ignore.
    {_, Rest1} = collect_to_eol(Rest),
    collect_to_fence(Rest1);

collect_code(Input) ->
    collect_to_unindent(Input).
all_code(Input) ->
    all_code(Input, []).

all_code("", Acc) ->
    lists:reverse(Acc);

all_code([$\n, $#, $#, $#, $#, $#, $#, $  | Rest], Acc) ->
    {Name, Rest1} = collect_to_eol(Rest),
    {Code, Rest2} = collect_code(Rest1),
    all_code(Rest2, [{Name, Code} | Acc]);

all_code([_ | Rest], Acc) ->
    all_code(Rest, Acc).
find_indentation("") ->
    "";

find_indentation(Code) ->
    {Line, Rest} = collect_to_eol(Code),
    case re:run(Line, "^(?<white>\\s*)\\S", [{capture, [white], list}]) of
        {match, [White]} ->
            White;
        nomatch ->
            find_indentation(Rest)
    end.
unindent(Code) ->
    case find_indentation(Code) of
        "" ->
            Code;
        Indentation ->
            Pattern = [$^ | Indentation],
            unindent(Code, Pattern, [])
    end.

unindent("", _Pattern, Lines) ->
    string:join(lists:reverse(Lines), "\n");

unindent(Code, Pattern, Lines) ->
    {Line, Rest} = collect_to_eol(Code),
    Unindented_line = re:replace(Line, Pattern, "", [{return, list}]),
    unindent(Rest, Pattern, [Unindented_line | Lines]).
unindent_blocks(Blocks) ->
    lists:map(fun ({Name, Code}) ->
                  {Name, unindent(Code)}
              end,
              Blocks).
concat_blocks(Blocks) ->
    Join_blocks = fun (Key, Acc) ->
        Values = proplists:get_all_values(Key, Blocks),
        Joined = string:join(Values, "\n"),
        [{Key, Joined} | Acc]
    end,

    lists:foldr(Join_blocks, [], proplists:get_keys(Blocks)).
collect_to_macro_delimeter(Line) ->
    collect_to_macro_delimeter(Line, "").

collect_to_macro_delimeter("", Acc) ->
    {lists:reverse(Acc), ""};

% Ignores escaped delimeters.
collect_to_macro_delimeter([$\\, $#, $#, $#, $#, $#, $# | Rest], Acc) ->
    collect_to_macro_delimeter(Rest, [$#, $#, $#, $#, $#, $#, $\\ | Acc]);

collect_to_macro_delimeter([$#, $#, $#, $#, $#, $# | Rest], Acc) ->
    {lists:reverse(Acc), Rest};

collect_to_macro_delimeter([Char | Rest], Acc) ->
    collect_to_macro_delimeter(Rest, [Char | Acc]).
macro(Line) ->
    case collect_to_macro_delimeter(Line) of
        {_, ""} ->
            % No macro in this line.
            nil;

        {Prefix, Rest} ->
            % Rest contains the macro name and, potentially, another
            % delimeter before the suffix.
            {Padded_name, Suffix} = collect_to_macro_delimeter(Rest),
            {string:strip(Padded_name), Prefix, Suffix}
    end.
expand_macros(Code, Blocks) ->
    expand_macros(Code, Blocks, []).

expand_macros("", _Blocks, Acc) ->
    string:join(lists:reverse(Acc), "\n");

expand_macros(Code, Blocks, Acc) ->
    {Line, Rest} = collect_to_eol(Code),
    case macro(Line) of
        nil ->
            expand_macros(Rest, Blocks, [Line | Acc]);

        {Name, Prefix, Suffix} ->
            case proplists:get_value(Name, Blocks) of
                undefined ->
                    io:format("Warning: code block named ~p not found.~n", [Name]),
                    expand_macros(Rest, Blocks, [Line | Acc]);

                Code_to_insert ->
                    New_lines = re:split(Code_to_insert, "\n", [{return, list}]),
                    Wrapped = lists:map(fun (X) -> Prefix ++ X ++ Suffix end, New_lines),
                    expand_macros(Rest, Blocks, [string:join(Wrapped, "\n") | Acc])
            end
    end.
expand_all_macros(Blocks) ->
    expand_all_macros(Blocks, Blocks, []).

expand_all_macros([], _Blocks, Acc) ->
    lists:reverse(Acc);

expand_all_macros([{Name, Code} | Rest], Blocks, Acc) ->
    expand_all_macros(Rest, Blocks, [{Name, expand_macros(Code, Blocks)} | Acc]).
unescape(Code) ->
    re:replace(Code, "\\\\######", "######", [global, {return, list}]).
unescape_blocks(Blocks) ->
    unescape_blocks(Blocks, []).

unescape_blocks([], Acc) ->
    lists:reverse(Acc);

unescape_blocks([{Name, Code} | Rest], Acc) ->
    unescape_blocks(Rest, [{Name, unescape(Code)} | Acc]).
file_blocks(Blocks) ->
    file_blocks(Blocks, []).

file_blocks([], Acc) ->
    lists:reverse(Acc);

file_blocks([{[$f, $i, $l, $e, $: | _] = Name, Code} | Rest], Acc) ->
    file_blocks(Rest, [{Name, Code} | Acc]);

file_blocks([_ | Rest], Acc) ->
    file_blocks(Rest, Acc).
file_name(Base_directory, File_name) ->
    filename:nativename(filename:absname_join(Base_directory, File_name)).

write_file(Base_directory, File_name, Contents) ->
    Fn = file_name(Base_directory, File_name),
    ok = file:write_file(Fn, Contents),
    Fn.
process_file(File_name) ->
    Base_directory = filename:dirname(File_name),
    Concatenated_code = concat_blocks(
                            unindent_blocks(
                                all_code(
                                    read_file(File_name)))),
    Expanded_code = expand_all_macros(
                        expand_all_macros(
                            expand_all_macros(
                                expand_all_macros(Concatenated_code)))),
    Files = file_blocks(
                unescape_blocks(Expanded_code)),

    write_file_blocks(Base_directory, Files, []).

write_file_blocks(_Base_directory, [], Files_written) ->
    lists:reverse(Files_written);

write_file_blocks(Base_directory, [{[$f, $i, $l, $e, $: | File_name], Contents} | Rest], Files_written) ->
    New_file = write_file(Base_directory, File_name, Contents),
    write_file_blocks(Base_directory, Rest, [New_file | Files_written]).
process_files(Files) ->
    process_files(Files, []).

process_files([], Files_written) ->
    % Files_written is a list of lists of strings. Strings are lists, too,
    % so lists:flatten can't be used becuause it turns into a single
    % string.
    lists:concat(lists:reverse(Files_written));

process_files([File | Files], Files_written) ->
    process_files(Files, [process_file(File) | Files_written]).
file_modified_time(File_name) ->
    {ok, Info} = file:read_file_info(File_name),
    Info#file_info.mtime.
modified_times(Files) ->
    Fun = fun (X, A) ->
        [{X, file_modified_time(X)} | A]
    end,
    lists:foldl(Fun, [], Files).
watch(Files, Fun) ->
    watch(Files, Fun, []).

watch(Files, Fun, State) ->
    Modified_times = modified_times(existing_files(Files)),
    Changed_files = changed_files(Modified_times, State),

    case length(Changed_files) > 0 of
        true ->
            apply(Fun, [Changed_files]);
        _ -> noop
    end,

    % wait
    timer:sleep(timer:seconds(1)),

    % loop
    watch(Files, Fun, Modified_times).
changed_files(A, B) ->
    Fun = fun (X, Acc) ->
        case proplists:get_value(X, A) =:= proplists:get_value(X, B) of
            false ->
                [X | Acc];
            _ -> Acc
        end
    end,
    lists:foldl(Fun, [], proplists:get_keys(A)).
existing_files(Files) ->
    lists:filter(fun filelib:is_file/1, Files).